# Feature Specification: Portable WASM Apps (Pixel Canvas)

**Feature Branch**: `001-wasm-pixel-canvas`
**Created**: 2026-01-13
**Status**: Draft
**Input**: User description:
> # Portable WASM apps  
> Goals:  
> 1. Straightforward to implement a compliant environment  
> 2. Single-file packages  
> 3. Portable (Web, Desktop, Mobile, Bare metal, …)  
> 4. Can be AOT compiled for a specific target  
> What:  
> A fixed-sized RGB pixel canvas living in linear memory, updated by a WASM program with WASI support.  
> The file format should contain:  
> - [ ] A header with a magic number  
> - [ ] A WASM program which can call the host’s `void update_frame(i32 width, i32 height, i32* pixels)` function, the provided pixel array is then drawn on the screen.  
> Platforms:  
> Desktop:  
> - Rust + Wasmtime + SDL3

## Clarifications
### Session 2026-01-13
- Q: Window resizing behavior? → A: Host window matches `update_frame` dimensions. User can resize window. Host calls optional `on_resize(w, h)` in WASM. WASM calls `update_frame` with new (or old) size, and Host window updates to match.
- Q: Input handling? → A: Host calls optional WASM exports: `on_pointer_move`, `on_pointer_down/up`, `on_key_down/up`.
- Q: Loop architecture? → A: Host calls guest export `update(dt: f64)`. Guest calculates frame and calls host `update_frame` to submit.
- Q: Magic number? → A: "WAPP" (ASCII) + 1-byte version (0x01).
- Q: Import namespace? → A: "wapps". (e.g. `(import "wapps" "update_frame" ...)`).

## User Scenarios & Verification *(mandatory)*

### User Story 1 - Run Portable WASM App (Priority: P1)

As an End User, I want to run a single-file portable WASM app on my desktop so that I can view the visual content it generates.

**Why this priority**: Core value proposition - enabling the execution of these apps.

**Independent Verification**: Can be verified by running a sample "Hello World" pixel app that draws a color to the screen.

**Acceptance Scenarios**:

1. **Given** a valid single-file WASM package with the correct header and WASM binary, **When** I run the application with this file, **Then** a window opens and displays the pixel content generated by the package.
2. **Given** the application is running, **When** the WASM module calls `update_frame`, **Then** the window content updates to reflect the provided pixel array.

---

### User Story 2 - Develop Compliant WASM App (Priority: P1)

As a Developer, I want to create a WASM app that conforms to the specification so that it runs on any compliant environment.

**Why this priority**: Essential to have content to run.

**Independent Verification**: Create a minimal WASM module using standard tools (e.g., Rust `wasm32-wasi` target) that imports the required function.

**Acceptance Scenarios**:

1. **Given** a Rust project targeting `wasm32-wasi`, **When** I implement logic to write to a byte buffer and call the host `update_frame` import, **Then** the compiled WASM (packaged with header) runs correctly in the environment.

---

### Edge Cases

- **Invalid File**: System MUST reject files with invalid magic number or version byte with a clear error message. Host MUST NOT crash.
- **WASI Calls**: System MUST support minimal WASI (clock, random, stdio). File system access MUST be disabled for security. Unsupported WASI calls should trap with clear error message.
- **Crash/Trap**: System MUST catch WASM traps/panics and display error message to user. Host MUST NOT crash; should exit gracefully or allow retry.

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: System MUST define a custom binary file format consisting of a Header followed immediately by the WASM binary.
- **FR-002**: System MUST validate the file header starting with the 5-byte sequence: Magic Number "WAPP" as ASCII bytes `[0x57, 0x41, 0x50, 0x50]` followed by Version byte `0x01`.
- **FR-003**: System MUST provide a Host Interface function `update_frame(param1: i32, param2: i32, param3: ptr)` that WASM modules can import from the module namespace "wapps".
  - `param1`: width (i32)
  - `param2`: height (i32)
  - `param3`: pointer to pixel data (i32*)
- **FR-004**: System MUST render the provided pixel array to the visual output (window/screen) when `update_frame` is called.
- **FR-005**: System MUST treat the pixel data as 32-bit RGBA values in RGBA8888 format. Each pixel is 4 consecutive bytes in memory: Red, Green, Blue, Alpha (R-G-B-A byte order). Alpha channel is supported for transparency (0x00 = transparent, 0xFF = opaque).
- **FR-006**: System MUST support WASI (WebAssembly System Interface) for standard system operations (e.g., I/O).
- **FR-007**: System MUST provide a linear memory environment for the WASM module.
- **FR-008**: System MUST be implemented as a Desktop application using Rust, Wasmtime, and SDL2.
- **FR-009**: System MUST allow the user to resize the Host window.
- **FR-010**: System MUST check for and call an optional WASM export `on_resize(width: i32, height: i32)` when the Host window is resized.
- **FR-012**: System MUST check for and call optional WASM exports for input events:
  - `on_pointer_move(x: i32, y: i32)`
  - `on_pointer_down(x: i32, y: i32, button: i32)` - button: 1=Left, 2=Middle, 3=Right
  - `on_pointer_up(x: i32, y: i32, button: i32)` - button: 1=Left, 2=Middle, 3=Right
  - `on_key_down(scancode: i32)` - scancode uses SDL2 scancode values
  - `on_key_up(scancode: i32)` - scancode uses SDL2 scancode values
- **FR-011**: System MUST update the Host window client area dimensions to match the `width` and `height` arguments passed in the most recent `update_frame` call (effectively snapping the window to the content size driven by the guest).
- **FR-013**: System MUST provide a main loop that calls the WASM export `update(dt: f64)` at approximately 60 FPS (targeting 16.67ms frame time), where `dt` is the delta time in seconds since the last frame. VSync may be enabled for smoother rendering.

### Key Entities

- **Pixel Buffer**: A contiguous array of memory bytes/integers representing the frame.
- **Guest**: The WASM module/application being executed.
- **Host**: The runtime environment that loads and executes the Guest.
- **Magic Number**: A unique byte sequence to identify the package type.

## Success Criteria *(mandatory)*

- **Quantitative**:
  - Sample App renders at 60 FPS (or reasonable refresh rate provided by Guest).
  - Application startup time < 1s for small samples.
  - Host implementation < 1000 lines of Rust code (excluding dependencies).
- **Qualitative**:
  - Single executable can load and run the single-file package.
  - Implementation uses standard Rust idioms with minimal complexity.

## Assumptions & Dependencies

- **Assumption**: Pixel format is standard 32-bit RGBA.
- **Assumption**: Loop is Host-driven (calls `update(dt)`), but Guest explicitly pushes pixel data by calling `update_frame`.
- **Dependency**: Wasmtime crate for Rust.
- **Dependency**: SDL2 bindings for Rust.
